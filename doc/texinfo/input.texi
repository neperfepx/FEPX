@c This file is part of the FEPX software package.
@c Copyright (C) 1996-2020, DPLab, ACME Lab.
@c See the COPYING file in the top-level directory.

@c I would perhaps like to change all @var{value} references defined below to refer to the datatype of the given input (e.g. 'integer', 'real', 'string', etc).

@node Simulation Input
@chapter Simulation Input

By default, a minimum of two files is necessary to completely define a simulation. These files are the configuration file, @file{simulation.config}, and the mesh file, @file{simulation.msh}. The configuration file defines the material parameters, control of the simulation (i.e., boundary conditions and loading history), printing of output files, and various optional input. The mesh file contains the polycrystal finite element mesh information (grain morphologies, phases and crystal orientations) as well as simulation-related information on the domain faces and the mesh partitions used for parallel simulations.

@node The Configuration File
@section The Configuration File (@file{simulation.config})

This file contains the necessary definitions to run a simulation. It is structured in several, successive @dfn{blocks} that define different aspects of the simulation.  Each of these blocks is headed by a line starting by @samp{##}, which provides a short description of the block.  The structure for the @file{simulation.config} file is as follows:

@inputfilehead
@example
 ## Optional Input
     @var{key_phrase} @var{value}
     ...

 ## Material Parameters
     @var{key_phrase} @var{value}
     ...

 ## Deformation History
     @var{key_phrase} @var{value}
     ...

 ## Boundary Conditions
     @var{key_phrase} @var{value}
     ...

 ## Printing Results
     @var{key_phrase} @var{value}
     ...

@end example
@inputfilefoot

Configuration options within a @dfn{block} may generally be provided in any order; however, the material parameters and deformation history must follow specific orders. It is recommended that the overall structure of the @file{simulation.config} file follow the example structure above. The @samp{Optional Input} block should always precede any others.

Any piece of text that is preceded by a @samp{#} is assumed to be a comment and is ignored (which also makes block headers optional), while @samp{@var{key_phrase} @var{value}} is the input structure of the file, where @code{@var{key_phrase}} is the input command and @code{@var{value}} are the associated parameters for the input command (as will be defined in the following sections).
A single line in the file should only ever pertain to a single @code{@var{key_phrase}}/@code{@var{value}} pairing. All strings are interpreted literally and should be lowercase except where otherwise stated.

@node Material Description
@subsection Material Description

The model is described in @ref{Model Description}, and the corresponding input paramaters are made clear and written in fixed font, most often as in `@math{\gamma} (@code{gamma})'.  The specification of the input parameters in the @file{simulation.config} file is detailed in @ref{Input Parameters}.

@node Model Description
@subsubsection Model Description

The material is described via an elastic response (Hooke's law) and a plastic response (rate dependent plastic flow and hardening).


The stress, @math{\sigma}, is related to the elastic strain, @math{\epsilon},  via Hooke's law:

@tex
$$ \sigma = \cal C \epsilon, $$
@end tex

where @math{\cal C} is the stiffness tensor, defined by the input parameters @option{c11}, @option{c12}, and @option{c44} for cubic materials, and  @option{c11},  @option{c12},  @option{c13}, and  @option{c44} for hexagonal materials.

@sp 1

The kinematics of slip are described by a power law:

@tex
$$ \dot{\gamma}^{\alpha} = \dot{\gamma}_{0}
         \left (\left|{\tau}^{\alpha}\right|
         \over g^{\alpha} \right)^{1/m} \rm sgn({\tau}^{\alpha}),  $$
@end tex

where
@iftex
@math{@dot{\gamma}_0}
@end iftex
@ifinfo
@math{{\gamma}_0 dot}
@end ifinfo
(@option{gammadot_0}) is the fixed-rate strain rate scaling coefficient (expressed in [force/area] @footnote{All variables presented in this chapter (if applicable) are detailed by their dimensions instead of any specific unit. No unit system is inherently assumed by FEPX and the chosen unit system and value magnitudes should be consistent with the chosen length scale for the domain. For example, if it is assumed that the length scale is @samp{mm} and SI units are to be used, then [force/area] will be understood to be [MPa]. The unit for time, however, is always assumed to be seconds [s].}), and @math{m} (@option{m}) is the rate sensitivity exponent.

@sp 1

For an isotropic hardening assumption @footnote{Note that for HCP materials, the implementation of an isotropic hardening assumption is  such that the shape of the single crystal yield surface is maintained. That is, the slip rates on the basal, prismatic, and pyramidal slip systems will harden such that the ratios of slip strengths remains constant. The consequence of this is that for HCP materials, this is not a true isotropic assumption, as the different slip families may harden at different rates (depending on the ratios of slip system strengths).}, slip system strength evolution (hardening) is modeled by:

@c evolution of slip strengths
@tex
$$ \dot{g^{\alpha}} = h_{0}
         \left (g_{s}(\dot{\gamma}) - g^{\alpha}
         \over g_{s}(\dot{\gamma}) - g_{0} \right)^{n} \dot{\gamma}, $$
@end tex

where @math{h_0} (@option{h_0}) is the fixed-state hardening rate scaling coefficient, @math{g_0} (@option{g_0}) is the initial slip system strength (expressed in [force/area]),
@c -- note that for hexagonal materials, the input parameters @option{prismatic_to_basal} and @option{pyramidal_to_basal} control the ratios of the initial slip system strengths
and @math{n} (@option{n}) is the non-linear Voce hardening exponent.

@sp 1

The slip system saturation strength may be evolved, and is calculated at a given state as:

@c saturation strength
@tex
$$ g_{s}(\dot{\gamma}) = g_{s0}
         \left (\dot{\gamma}
         \over \dot{\gamma}_{s0} \right)^{m'}, $$
@end tex

where @math{g_{s0}} (@option{g_s0}) is the initial slip system saturation strength (expressed in [force/area]), @math{m'} (@option{m_prime}) is the saturation strength rate scaling exponent, and
@iftex
@math{@dot{\gamma}_{s0}}
@end iftex
@ifinfo
@math{\gamma_{s0} dot}
@end ifinfo
(@option{gammadot_s0}) is the initial saturation slip system shear rate. Note that, in the above two equations,
@iftex
@math{@dot{\gamma}}
@end iftex
@ifinfo
@math{\gamma dot}
@end ifinfo
is calculated as:

@tex
$$ \dot{\gamma} = \sum_{\alpha}
         \left|\dot{\gamma}^{\alpha}\right|. $$
@end tex

@sp 1
@need 1200
For a cyclic hardening assumption, the slip system strength evolution (hardening) is modeled by:

@tex
$$ \dot{g^{\alpha}} = h_{0}
         \left (g_{s}(\dot{\gamma}) - g^{\alpha}
         \over g_{s}(\dot{\gamma}) - g_{0} \right)^{n} f, $$
@end tex

where @math{f} is calculated as:

@tex
$$ f = \sum_{\beta = 0}^{n_{a}}
         \left|\dot{\gamma}^{\beta}\right| . $$
@end tex

A slip system that contributes to hardening (@math{n_{a}} total systems contributing to hardening) is that which has a change in shear greater than a critical value:

@tex
$$ \Delta\gamma_{crit} = a
         \left[\, g / g_{s}(\dot{\gamma}) \right]^{c}, $$
@end tex

where the material parameters here are @math{a} (@option{cyclic_parameter_a}) and @math{c} (@option{cyclic_parameter_c}). A more complete description can be found in Turkmen @emph{et al.} [@value{turk_daw_04}]. Note that minor differences exist between the implemented model described above and the formulation described in the paper.

@sp 1

For an anisotropic hardening assumption, slip system strength evolution (hardening) is modeled by:

@tex
$$ \dot{g^{\alpha}} = h_{0}
         \left (g_{s}(\dot{\gamma}) - g^{\alpha}
         \over g_{s}(\dot{\gamma}) - g_{0} \right)^{n} \dot{\gamma} h_{\alpha \beta}, $$
@end tex

where the model parameters are the same as the isotropic case described above, with the addition of @math{h_{\alpha \beta}}, the slip interaction matrix. The slip interaction matrix only allows for interactions from direct and coplanar slip families. The slip interaction matrix is defined by the diagonal entry, @math{d}, and the off-diagonal entries, @math{h_{1},\dots, h_{n}}. These input parameters are defined by @option{diag}, @option{h1}, @option{h2}, @option{h3}, and @option{h4} for FCC materials, @option{diag}, @option{h1}, @option{h2}, @option{h3}, @option{h4}, @option{h5}, and @option{h6} for BCC materials, and @option{diag}, @option{h1}, @option{h2}, @option{h3}, @option{h4}, @option{h5}, @option{h6}, and @option{h7} for HCP materials. A more complete description can be found in Carson @w{@emph{et al.} [@value{car_daw_17}]}.

For a hexagonal material, the c/a ratio (@option{c_over_a}) must also be defined. The initial slip strengths (@option{g_0}) must be provided as a set of three values. The order of the values for @option{g_0} is assumed to be: basal slip family strength, prismatic slip family strength, and pyramidal slip family strength.

@node Input Parameters
@subsubsection Input Parameters

The material (as defined in the mesh file) can include one or several phases (to which grains are assigned), and the mechanical behavior of these phases must be defined accordingly. The number of phases must first be provided:

@inputfilehead
@example
@option{number_of_phases} @var{value}
@end example
@inputfilefoot

The material parameters for a particular phase should be defined entirely for said phase before parameters for any subsequent phases are defined.

@sp 1
Each phase requires the specification of a consistent set of single-crystal material parameters, prefaced by

@inputfilehead
@example
@option{phase} @var{value}
@end example
@inputfilefoot

where @code{@var{value}} is the phase identification number (ranging from 1 to @var{nphases}).

@c DEBUG: `nphases` is not defined anywhere. Should be `number_of_phases` instead?
@c Any values defined after @code{@var{curr_phase}} will be applied to all grains of the phase.
@need 1200
First, the crystal symmetry is defined by:

@inputfilehead
@example
@option{crystal_type} @var{type_string}
@end example
@inputfilefoot

where @code{@var{type_string}} is the crystal symmetry type. Options for @code{@var{type_string}} are: @samp{fcc}, @samp{bcc}, and @samp{hcp}, for face-centered cubic, body-centered cubic, and hexagonal close-packed, respectively.

Then, the single-crystal elastic and plastic material parameters of the phase must be defined.
Depending on the crystal symmetry, the total number of required parameters varies.
Below, all @code{@var{value}} inputs are expected to be real numerical values.

@c The number of phases defined in the @file{simulation.config} file must match the maximum @code{@var{group}} value in the @file{simulation.msh} file.

Anisotropic elastic constants are defined using the strength of materials convention. The input is, for @samp{fcc} and @samp{bcc} crystal structures:

@inputfilehead
@example
@option{c11} @var{value}
@option{c12} @var{value}
@option{c44} @var{value}
@end example
@inputfilefoot

and, for an @samp{hcp} crystal structure:

@inputfilehead
@example
@option{c11} @var{value}
@option{c12} @var{value}
@option{c13} @var{value}
@option{c44} @var{value}
@end example
@inputfilefoot

where @option{c11-c44} are expressed in [force/area]. For @samp{hcp} materials, the @math{C_{33}} elastic constant is constrained by the other four nonzero moduli and is not required as direct input.

For the @samp{hcp} crystal structure, an additional crystal parameter needs to be provided:

@inputfilehead
@example
@option{c_over_a} @var{value}
@end example
@inputfilefoot

Crystallographic slip (plasticity) parameters are defined as:

@inputfilehead
@example
@option{m} @var{value(s)}
@option{gammadot_0} @var{value}
@option{h_0} @var{value}
@option{g_0} @var{value(s)}
@option{g_s0} @var{value}
@option{m_prime} @var{value}
@option{gammadot_s0} @var{value}
@option{n} @var{value}
@end example
@inputfilefoot

For hexagonal materials, multiple values may be provided for the rate sensitivity exponent, @samp{m}, and the initial slip system strengths, @option{g_0}. If a single value is provided for @option{m}, a constant rate sensitivity exponent is assumed across all slip families. If three values are provided for @option{m}, varying rate sensitivity exponents are applied on a per-slip family basis. Additionally, @option{g_0} must be defined by three unique values. The order of the values for @option{m} and @option{g_0} is assumed to be: basal slip family, prismatic slip family, and pyramidal slip family.

@c {@bf The next 6 lines should be moved to 2.1.1.1, when not already present there (don't repreat the definitions). Some of the terms appearing here are not to be defined in 2.1.1.1 - fix.}@*
@c where @option{m} is the fixed-state strain rate sensitivity,
@c @option{gammadot_0} is the fixed-state strain rate scaling coefficient (expressed in [force/area]),
@c @option{h_0} is the strength hardening rate coefficient (expressed in [force/area]), @option{g_0} is the initial slip system strength , @option{g_s0} is the reference value of saturation strength (expressed in [force/area]), @option{m_prime} is the saturation strength rate scaling exponent, @option{gammadot_s0} is the saturation strength strain rate scaling coefficient, and @option{n} is the exponent on the modified Voce hardening term.

Finally, if @dfn{cyclic} hardening is enabled, each phase requires the definition of two additional parameters by:

@inputfilehead
@example
@option{cyclic_parameter_a} @var{value}
@option{cyclic_parameter_c} @var{value}
@end example
@inputfilefoot

where both @option{cyclic_parameter_*} values are model parameters for a critical value of accumulated shear strain used to modify the form of the Voce hardening law [@value{turk_daw_04}].

Else, if @dfn{latent} hardening is enabled, each phase requires the definition of slip interaction matrix values which vary based on crystal symmetry.

For an @samp{fcc} crystal structure:

@inputfilehead
@example
@option{latent_parameters} @var{diag} @var{h1} @var{h2} @var{h3} @var{h4}
@end example
@inputfilefoot

For an @samp{bcc} crystal structure:

@inputfilehead
@example
@option{latent_parameters} @var{diag} @var{h1} @var{h2} @var{h3} @var{h4} @var{h5} @var{h6}
@end example
@inputfilefoot

For an @samp{hcp} crystal structure:

@inputfilehead
@example
@option{latent_parameters} @var{diag} @var{h1} @var{h2} @var{h3} @var{h4} @var{h5} @var{h6} @var{h7}
@end example
@inputfilefoot

where @code{@var{diag}} is the diagonal coefficient and @code{@var{h1-h7}} are the slip family coefficients [@value{car_daw_17}].

@node Deformation History
@subsection Deformation History

A variety of deformation modes are available that are capable of reproducing various mechanical loading configurations. A deformation history is defined by both steps and increments, where steps are made of one or several increments. Steps define the strain or load targets that are to be reached during the simulation, and results can only be printed at the end of steps. One or several increments occur within each step to reach the prescribed step target while ensuring numerical stability. A step target can be expressed in terms of @dfn{strain} or @dfn{load}. The @dfn{strain} refers to the engineering strain as computed from the displacement of the loading surface and the initial sample length along the loading direction, and the @dfn{load} refers to the total force on the loading surface. Of course, the relative order of the steps defined for the deformation history matters and should be written in an ascending manner.

Deformation histories are divided into uniaxial loading and multiaxial loading. In general, the multiaxial loading definition is technically triaxial in nature; however, biaxial loading may be performed by zeroing out one of the load columns accordingly. The available deformation history configuration options follow.

@node DH Uniaxial
@subsubsection Uniaxial

Uniaxial loading is always strain controlled (internally); however, either specific strain targets or specific load targets may be prescribed. For strain targeting, the number of increments for a given step must be provided as opposed to a time-step value. For load targeting, the bounds on the time-step value are provided in order to control both the accuracy and, indirectly, the number of increments taken per step. These time-step values should be defined relative to the @option{strain_rate} value (@pxref{Boundary Conditions}).

Strain targeting allows the definition of loading to specific uniaxial strain states. This deformation history is defined as follows:

@inputfilehead
@example
@option{def_control_by} @option{uniaxial_strain_target}
@option{number_of_strain_steps} @var{nsteps}
@option{target_strain} @var{target_val} @var{n_incr} @var{print_flag}
...
@end example
@inputfilefoot

where @code{@var{nsteps}} is the number of strain steps that are defined in the file after this line, @code{@var{target_val}} is the desired strain value to be reached, @code{@var{n_incr}} is the number of increments to be performed in order to complete the step, and @code{@var{print_flag}} allows for the printing (or not) of specific steps. The options available for @code{@var{print_flag}} are: @samp{print_data} or @samp{suppress_data}.

Load targeting allows the definition of loading to specific uniaxial load states. This deformation history is defined as follows:

@inputfilehead
@example
@option{def_control_by} @option{uniaxial_load_target}
@option{number_of_load_steps} @var{nsteps}
@option{target_load} @var{target_val} @var{dt_max} @var{dt_min} @var{print_flag}
...
@end example
@inputfilefoot

where @code{@var{nsteps}} is the number of load steps that are defined in the file after this line, @code{@var{target_val}} is the desired load value to be reached, @code{@var{dt_max}} is the maximum time-step value to be used for a given increment, @code{@var{dt_min}} is the minimum time-step value to be used for a given increment, and @code{@var{print_flag}} allows for the printing (or not) of specific steps. The options available for @code{@var{print_flag}} are: @samp{print_data} or @samp{suppress_data}.

Strain rate jumps are also available for both uniaxial deformation modes and are defined by adding the following input to the block:

@inputfilehead
@example
@option{number_of_strain_rate_jumps} @var{njumps}
@option{strain_rate_jump} @var{target_step} @var{new_strain_rate}
...
@end example
@inputfilefoot

where @code{@var{njumps}} is the number of strain rate jumps defined in the file after this line, @code{@var{target_step}} defines which @option{target_strain} step is assigned a new strain rate, and @code{@var{new_strain_rate}} is the new strain rate to be assigned and has units of [1/s]. In general, and for numerical stability, the strain rate jumps should be of a similar magnitude to the @option{strain_rate} defined previously.

@node DH Multiaxial
@subsubsection Multiaxial

Multiaxial loading is always strain controlled (internally) and operates at either a constant engineering strain rate or constant load rate; however, only specific load targets may be prescribed.
The principal loading directions must be aligned with the coordinate axes of the mesh and the surface face normals should likewise be coincident with the coordinate axis of the mesh. Symmetry boundary conditions (zero normal velocities) are enforced on the three faces of minimal coordinates (@samp{@var{*0}}), and, in the general case, non-zero normal velocities are applied to the faces of maximal coordinates (@samp{@var{*1}}). The velocity on the primary control surface is held constant through the simulation (except during a strain rate jump).

Multiaxial loading with a constant strain rate (CSR) is defined as follows:

@inputfilehead
@example
@option{def_control_by} @option{triaxial_constant_strain_rate}
@option{number_of_csr_load_steps} @var{nsteps}
@option{target_csr_load} @var{load_x} @var{load_y} @var{load_z} @var{dt_max} @var{dt_min} @var{print_flag}
...
@end example
@inputfilefoot

where @code{@var{nsteps}} is the number of CSR load steps that are defined in the file after this line, @code{@var{load_x}} is the desired load value to be reached in the @samp{x} coordinate axis direction, @code{@var{load_y}} is the desired load value to be reached in the @samp{y} coordinate axis direction, @code{@var{load_z}} is the desired load value to be reached in the @samp{z} coordinate axis direction, @code{@var{dt_max}} is the maximum time-step value to be used for a given increment, @code{@var{dt_min}} is the minimum time-step value to be used for a given increment, and @code{@var{print_flag}} allows for the printing (or not) of specific steps. The options available for @code{@var{print_flag}} are: @samp{print_data} or @samp{suppress_data}.

Strain rate jumps are available for this deformation mode and are defined by adding the following input to the block:

@inputfilehead
@example
@option{number_of_strain_rate_jumps} @var{njumps}
@option{strain_rate_jump} @var{target_step} @var{new_strain_rate}
...
@end example
@inputfilefoot

where @code{@var{njumps}} is the number of strain rate jumps defined in the file after this line, @code{@var{target_step}} defines which @option{target_csr_load} step is assigned a new strain rate, and @code{@var{new_strain_rate}} is the new strain rate to be assigned and has units of [1/s].

Multiaxial loading with a constant load rate (CLR) is defined as follows:

@inputfilehead
@example
@option{def_control_by} @option{triaxial_constant_load_rate}
@option{number_of_clr_load_steps} @var{nsteps}
@option{target_clr_load} @var{load_x} @var{load_y} @var{load_z} @var{target_time_incr} @var{print_flag}
...
@end example
@inputfilefoot

where @code{@var{nsteps}} is the number of CLR load steps that are defined in the file after this line, @code{@var{load_x}} is the desired load value to be reached in the @samp{x} coordinate axis direction, @code{@var{load_y}} is the desired load value to be reached in the @samp{y} coordinate axis direction, @code{@var{load_z}} is the desired load value to be reached in the @samp{z} coordinate axis direction, @code{@var{target_time_incr}} is the physical time increment to be reached for the given @option{target_clr_load} steps for a given load rate, and @code{@var{print_flag}} allows for the printing (or not) of specific steps. The options available for @code{@var{print_flag}} are: @samp{print_data} or @samp{suppress_data}.

Load rate jumps and dwell episodes are available for this deformation mode. A dwell episode maintains the macroscopic loads of the step in which it is defined, but holds the ramp rate at zero for the amount of time defined by @code{@var{dwell_time}}. These options are defined as follows:

For load rate jumps:

@inputfilehead
@example
@option{number_of_load_rate_jumps} @var{njumps}
@option{load_rate_jump} @var{target_step} @var{new_ramp_rate}
...
@end example
@inputfilefoot

where @code{@var{njumps}} is the number of load rate jumps defined in the file after this line, @code{@var{target_step}} defines which @option{target_clr_load} step is assigned a new load rate, and @code{@var{new_load_rate}} is the new load rate to be assigned and has units of [force/s].

For dwell episodes:

@inputfilehead
@example
@option{number_of_dwell_episodes} @var{nepisodes}
@option{dwell_episode} @var{target_step} @var{dwell_time} @var{target_time_incr} @var{print_flag}
...
@end example
@inputfilefoot

where @code{@var{nepisodes}} is the number of dwell episodes defined in the file after this line, @code{@var{target_step}} defines which @option{target_clr_load} step is assigned to dwell, @code{@var{dwell_time}} is the physical amount of time in [s] for a given dwell episode, @code{@var{target_time_incr}} is the physical time increment to be reached for the given dwell episode, and @code{@var{print_flag}} allows for the printing (or not) of specific steps. The options available for @code{@var{print_flag}} are: @samp{print_data} or @samp{suppress_data}.

@c Need to confirm the "physicality" of the target_time_incr and how it is used internally.

@node Boundary Conditions
@subsection Boundary Conditions

Standard, simple boundary conditions are available for automatic definition with minimal input and are computed internally for each simulation based on the definitions in the @file{simulation.config} file. This ensures that standard boundary conditions are consistently defined for all simulations and increases the portability of the @file{simulation.config} file.
Alternatively, custom boundary conditions can be defined, as described separately, in @ref{Externally Defined Boundary Conditions (Optional)}.

@node BC Uniaxial
@subsubsection Uniaxial

Uniaxial definitions are available for three different constraint configurations. The available uniaxial constraint configuration options follow.

@dfn{Grip boundary conditions} fully constrain two opposite faces in the spatial domain. The first face is fully fixed in all sample directions while the second face has a strain rate applied in the face normal direction while the other two sample directions are fully fixed. All other faces are unconstrained.

@center @image{images/gripbcs,, 2.5in}
Figure 1. Simplified schematic of the applied velocities for grip boundary conditions. The loading face is @samp{z1} and the sample is being loading in the @samp{+Z} direction.

Grip boundary conditions are defined as follows:

@inputfilehead
@example
@option{boundary_conditions} @option{uniaxial_grip}
@option{loading_direction} @var{sample_dir}
@option{loading_face} @var{face_label}
@option{strain_rate} @var{value}
@end example
@inputfilefoot

where @code{@var{sample_dir}} is the direction along the a positive sample axis in which the sample is loaded, @code{@var{face_label}} is the face on which the loading is applied (the opposing face is fully fixed), and @code{@var{value}} is the strain rate value in units of [1/s].

@dfn{Symmetry boundary conditions} constrains four faces in the spatial domain. The three @code{@var{*0}} faces are fixed in the face normal directions and unconstrained in the other two sample directions. The fourth @code{@var{*1}} face has a strain rate applied in the face normal direction while the other two sample directions are fully fixed. The selection of the @code{@var{*1}} face is based on the defined @option{loading_direction}.

@center @image{images/symmbcs,, 2.5in}
Figure 2. Simplified schematic of the applied velocities for symmetry boundary conditions. The sample is being loaded in the @samp{+Z} direction.

Symmetry boundary conditions are defined as follows:

@inputfilehead
@example
@option{boundary_conditions} @option{uniaxial_symmetry}
@option{loading_direction} @var{sample_dir}
@option{strain_rate} @var{value}
@end example
@inputfilefoot

where @code{@var{sample_dir}} is the direction along the a positive sample axis in which the sample is loaded, and @code{@var{value}} is the strain rate value in units of [1/s].

@dfn{Minimal boundary conditions} are a modification of grip boundary conditions that only constrain two opposite faces in the face normal directions and two corner nodes in the spatial domain. The selection of the constrained faces is based on the defined @option{loading_direction}. The first node is always fully fixed where the @code{@var{*0}} faces converge. The second node is defined relative to the defined @option{loading_direction} and is constrained to prevent rigid body rotation about the @option{loading_direction} axis.

@center @image{images/minimalbcs,, 2.5in}
Figure 3. Simplified schematic of the applied velocities for minimal boundary conditions. The sample is being loaded in the @samp{+Z} direction. The two blue corner nodes are constrained to prevent rigid body translation and motion.

Minimal boundary conditions are defined as follows:

@inputfilehead
@example
@option{boundary_conditions} @option{uniaxial_minimal}
@option{loading_direction} @var{sample_dir}
@option{strain_rate} @var{value}
@end example
@inputfilefoot

where @code{@var{sample_dir}} is the direction along the a positive sample axis in which the sample is loaded, and @code{@var{value}} is the strain rate value in units of [1/s].

@node BC Multiaxial
@subsubsection Multiaxial

Multiaxial boundary conditions are generally consistent across modes, however, the input rate type varies depending on the mode. For both modes, the @option{loading_direction} defines the primary control direction in which the normal velocities are held constant throughout the simulation.

Multiaxial loading with a constant strain rate (CSR) is defined as follows:

@inputfilehead
@example
@option{boundary_conditions} @option{triaxial}
@option{loading_direction} @var{sample_dir}
@option{strain_rate} @var{value}
@end example
@inputfilefoot

where @code{@var{sample_dir}} is the direction along the a positive sample axis in which the sample is loaded, and @code{@var{value}} is the strain rate value in units of [1/s].

Multiaxial loading with a constant load rate (CLR) is defined as follows:

@inputfilehead
@example
@option{boundary_conditions} @option{triaxial}
@option{loading_direction} @var{sample_dir}
@option{load_rate} @var{value}
@end example
@inputfilefoot

where @code{@var{sample_dir}} is the direction along the a positive sample axis in which the sample is loaded, and @code{@var{value}} is the loading rate value in units of [force/(area-s)].

@node Externally Defined Boundary Conditions (Optional)
@subsection Externally Defined Boundary Conditions (Optional)

Boundary conditions different from the ones defined in @ref{Boundary Conditions} can be applied using an external @file{simulation.bcs} containing per-node constraints. Of course, this file should be generated for a singular @file{simulation.msh} file (if the finite element mesh in the @file{simulation.msh} file changes, then the associated @file{simulation.bcs} file will need to be generated anew).

To read in external boundary conditions, the following line must be added to the @file{simulation.config} file:

@inputfilehead
@example
@option{read_bcs_from_file}
@end example
@inputfilefoot

The per-node constraints are defined as follows, in the @file{simulation.bcs} file:

@inputfilehead
@example
@var{node_id} @var{coord_index} @var{vel}
...
@end example
@inputfilefoot

where @code{@var{node_id}} is a unique 1-indexed identification number, @code{@var{coord_index}} defines the sample axis the constraint is applied to, and @code{@var{vel}} is the velocity being applied to the node in the constraint direction. The options for @code{@var{coord_index}} are: @samp{x}, @samp{y}, or @samp{z}. A singular @code{@var{coord_index}}/@code{@var{vel}} pair should be defined per-line for a given @code{@var{node_id}}.  The velocities should be prescribed relative to the mesh dimensions and time-step size in order to produce expected strain rates.

@node Externally Defined Orientations or Phase Assignments (Optional)
@subsection Externally Defined Phases and Orientations (Optional)

Crystallographic phase and orientations different from the ones defined in the @file{simulation.msh} file can be defined in external files by adding appropriate commands to the configuration file.

To read in external orientations, the following line must be added to the @file{simulation.config} file:

@inputfilehead
@example
@option{read_ori_from_file}
@end example
@inputfilefoot

More detailed information on the structure of this external file can be found in @ref{External Orientation Assignment (Optional)}.

To read in external grain/phase assignments, the following line must be added to the @file{simulation.config} file:

@inputfilehead
@example
@option{read_phase_from_file}
@end example
@inputfilefoot

More detailed information on the structure of this external file can be found in @ref{External Crystallographic Phase Assignment (Optional)}.

@node Printing Results
@subsection Printing Results

Each field variable file to be output from a simulation must be individually defined. This includes nodal output, elemental output, simulation restart information, fiber-averaging output, and other miscellaneous output (@pxref{Simulation Output} for a complete description of all output). The printing of a given field variable file is defined as follows:

@inputfilehead
@example
@option{print} @var{output_file_name}
@end example
@inputfilefoot

where @code{@var{output_file_name}} is the particular field variable file to be output. The available options for @code{@var{output_file_name}} are:

@itemize

@item @samp{coo} - Nodal coordinates

@item @samp{crss} - Critical resolved shear stress

@item @samp{defrate} - Deformation rate tensor

@item @samp{defrate-eq} - Equivalent deformation rate

@item @samp{defrate-pl} - Plastic deformation rate tensor

@item @samp{defrate-pl-eq} - Equivalent plastic deformation rate

@item @samp{elt-vol} - Elemental Volume

@item @samp{ori} - Crystallographic orientations

@item @samp{slip} - Slip system shear

@item @samp{sliprate} - Slip system shear rate

@item @samp{spinrate} - Plastic spin rate tensor

@item @samp{strain-eq} - Equivalent total strain

@item @samp{strain-el} - Elastic strain tensor

@item @samp{strain-pl-eq} - Equivalent plastic strain

@item @samp{stress} - Stress tensor

@item @samp{stress-eq} - Equivalent stress

@item @samp{vel} - Nodal velocity

@item @samp{velgrad} - Velocity gradient tensor

@item @samp{work} - Work

@item @samp{work-pl} - Plastic work

@item @samp{restart} - Simulation restart data

@item @samp{forces} - Surface forces

@item @samp{convergence} - Simulation convergence statistics

@end itemize

A full description of each output variable can be found in @ref{Simulation Output}.

@node Fiber Averaging of Output Variables (Optional)
@subsection Fiber Averaging of Output Variables (Optional)

The average and standard deviation of certain output variables may be calculated depending on whether or not they belong to a user-defined crystallographic fiber. To activate this option, the following line must be added to the @file{simulation.config} file:

@inputfilehead
@example
@option{run_fiber_average}
@end example
@inputfilefoot

More detailed information on the structure of this external file can be found in @ref{The Fiber Averaging File (Optional)}.

@node Optional Input Parameters
@subsection Optional Input Parameters

These options may pertain to specific deformation modes or control standard simulation behavior. All possible inputs presented in this section have default values already defined.

@sp 1
@itemize

@item @option{max_incr} @code{[integer]} specifies the maximum number of increments (default: @samp{50000}).

@item @option{max_total_time} @code{[real]} specifies the maximum deformation time (default: @samp{12000.0}).

@item @option{check_necking} @code{[@samp{on}/@samp{off}]} specifies whether or not to terminate simulation when specimen begins to neck (default: @samp{off}).

@item @option{load_tol} @code{[positive real]} is the the target load tolerance. A small positive load tolerance (e.g. 0.1 x control surface area) improves load control while reducing the number of small steps near target loads (default: @samp{0.0}).

@item @option{dtime_factor} @code{[real]} is a number greater than or equal to 1 which is used when calculating time increments near target loads (default: @samp{1.001}).

@item @option{hard_type} @code{[@samp{isotropic}/@samp{latent}]} specifies the hardening model to use (default: @samp{isotropic}).

@item @option{max_bc_iter} @code{[integer]} specifies the maximum number of boundary condition iterations (default: @samp{10}).

@item @option{min_pert_frac} @code{[real]} is the minimum fraction of the control velocity by which the secondary and tertiary surface velocities are perturbed during boundary condition iterations (default: @samp{0.001}).

@item @option{load_tol_abs} @code{[real]} is the absolute tolerance on the secondary and tertiary loads. The absolute load criterion is that both loads are within the absolute load tolerance of the ideal load. Loads are considered to be within tolerance if either the absolute or relative criterion is satisfied (default: @samp{0.1}).

@item @option{load_tol_rel} @code{[real]} is the relative load tolerance on the secondary and tertiary loads. It represents a fraction of the load in the control direction. The relative load criterion is that the difference between the load and ideal load, normalized by the load in the control direction, is less than the relative load tolerance. Loads are considered to be within tolerance if either the absolute or relative criterion is satisfied (default: @samp{0.001}).

@item @option{max_strain_incr} @code{[real]} specifies the maximum strain increment for dwell episodes (default: @samp{0.001}).

@item @option{max_strain} @code{[real]} specifies the maximum allowable macroscopic strain (default: @samp{0.2}).

@item @option{max_eqstrain} @code{[real]} specifies the maximum allowable macroscopic equivalent strain (default: @samp{0.2}).

@end itemize

@c DEBUG: The below line can likely be removed and we can just add the input commands 
@c to the above itemized list accordingly (adding the references per-line). - JC
Additional input commands related to fiber-averaging routines, restart capabilities and external file read-in are presented separately, @pxref{The Fiber Averaging File (Optional)},
@ref{Restarting a Simulation}, @ref{External Orientation Assignment (Optional)}, and @ref{External Crystallographic Phase Assignment (Optional)}, respectively.

@node Optional Convergence Parameters
@subsection Optional Convergence Parameters

These options modify the tolerances and general behavior of the solution algorithms and should only be modified by those who know what they are doing. All possible inputs presented in this section have default values already defined.

@node Velocity Convergence
@subsubsection Velocity Convergence

The velocity solver employs a hybrid successive-approximation/Newton-Raphson algorithm. Convergence of the velocity solution is based on a convergence parameter, which unless otherwise noted, is defined as the norm of the change in the velocity field, divided by the norm of the velocity field, @math{||\Delta u||/||u||}. Other parameters are also used to assess the convergence of the velocity solution. The following parameters pertain to the convergence of the velocity solver:

@sp 1
@itemize

@item @option{nl_max_iters} @code{[integer]} specifies the maximum allowable number of iterations of the nonlinear velocity solver (default: @samp{50}).

@item @option{nl_tol_strict} @code{[real]} specifies the desired tolerance on the elasto-viscoplastic velocity solution (default: @samp{5e-4}).

@item @option{nl_tol_loose} @code{[real]} specifies an acceptable level of convergence if the desired level of convergence cannot be reached via @samp{nl_tol_strict} (default: @samp{5e-4}).

@item @option{nl_tol_min} @code{[real]} is the tolerance on the norm of the change in velocity, divided by the number of degrees of freedom, @math{(||u||/ \rm max(ndof))}. This parameter is useful for assessing convergence when the macroscopic velocity is near zero (default: @samp{1e-10}).

@item @option{nl_tol_switch_ref} @code{[real]} is the value of the convergence parameter at which the solution algorithm switches from successive-approximation to Newton-Raphson. To only use successive-approximations, set the value of @samp{nr_tol_switch_ref} equal to the value of @samp{nl_tol_strict} (default: @samp{1e-2}).

@item @option{nl_tol_conv} @code{[real]} is a parameter between 0 and 1 that is used to assess whether the Newton-Raphson algorithm is converging slowly (default: @samp{0.2}).

@end itemize

@node Conjugate Gradient Convergence
@subsubsection Conjugate Gradient Convergence

The solution of the linear system of equations @math{[K]\{\Delta u\} = -\{R\}} is performed using a conjugate gradient solver. The following parameters pertain to the convergence of the conjugate gradient solver:

@sp 1
@itemize

@item @option{cg_max_iters} @code{[integer]} specifies the maximum allowable number of iterations of the conjugate gradient solver (default: @samp{16000}).

@item @option{cg_tol} @code{[real]} specifies the desired tolerance on the conjugate gradient solver (default: @samp{1e-8}).
@end itemize

@node Material State Convergence
@subsubsection Material State Convergence

The convergence of the material stress state for both the viscoplastic and elasto-viscoplastic solutions is assessed by the following parameters:

@sp 1
@itemize

@item @option{sx_max_iters_state} @code{[integer]} specifies the maximum number of iterations on material state (default: @samp{100}).

@item @option{sx_max_iters_newton} @code{[integer]} specifies the maximum number of iterations of the Newton algorithm used to solve for crystal stress (default: @samp{100}).

@item @option{sx_tol} @code{[real]} specifies the tolerance on the stress solution (default: @samp{1e-4}).

@end itemize


@node The Mesh File
@section The Mesh File (@file{simulation.msh})

This file contains the finite element mesh information along with phase assignments and crystal orientations. The mesh file is generally generated by Neper and not directly modified.  A brief description is provided below, which a more complete description can be found in the Neper reference manual, @url{https://neper.info/docs/neper.pdf}.  The file can be opened by Gmsh for interactive visualization.

The file is structured in several, successive @dfn{fields} that define different aspects of the mesh. Each of these fields is wrapped by @samp{$@var{Field}/$End@var{Field}} lines, where @samp{@var{Field}} is a short description of the information stored within the block. A typical @file{simulation.msh} file will contain the following information:

@itemize

@item Mesh Format (@samp{$MeshFormat}),

@item Mesh Version (@samp{$MeshVersion}),

@item Nodes (@samp{$Nodes}),

@item Elements (@samp{$Elements}),

@item Surface Element Sets (@samp{$Fasets}),

@item Crystal Orientations (@samp{$ElsetOrientations} or @samp{$ElementOrientations}),

@item Grain/Phase Assignments (@samp{$Groups}).

@end itemize

Additionally, the @file{simulation.msh} file may also include fields with partition information for both the nodes and elements if the domain is decomposed for parallel execution and surface node sets (@samp{$NSets}).

Embedded microstructural information (phases and orientations) with the @file{simulation.msh} may be overridden by external files, @file{simulation.ori} and @file{simulation.phase}, if the appropriate commands are added to the @file{simulation.config} file (@pxref{Externally Defined Orientations or Phase Assignments (Optional)}).

@node External Orientation Assignment (Optional)
@subsection External Orientation Assignment (Optional, @file{simulation.ori})

The embedded orientation assignments within the @file{simulation.msh} may be overridden via an external @file{simulation.ori} file. This file contains formatting identical to the associated fields in the mesh file and is defined as:

For per-grain (or @samp{Elset}) orientations:

@inputfilehead
@example
$ElsetOrientations
@var{number_of_ori_entities} @var{orientation_descriptor}:@var{orientation_convention}
@var{entity_id} @var{ori_des1} ...
...
$EndElsetOrientations
@end example
@inputfilefoot

For per-element orientations:

@inputfilehead
@example
$ElementOrientations
@var{number_of_ori_entities} @var{orientation_descriptor}:@var{orientation_convention}
@var{entity_id} @var{ori_des1} ...
...
$EndElementOrientations
@end example
@inputfilefoot

where @code{@var{number_of_ori_entities}} is the number of unique orientations defined in the section, @code{@var{orientation_descriptor}} is the parameterization for the orientations (see options below), @code{@var{orientation_convention}} describes the basis transformation route for the orientations provided, @code{@var{entity_id}} is a unique 1-indexed identification number, and @code{@var{ori_des*}} are the components of the unique orientation. Available options for @code{@var{orientation_convention}} are: @samp{active} or @samp{passive}. Following the usual terminology, an @dfn{active} orientation assumes that which describes a basis transformation from the sample basis to the crystal basis (sample-to-crystal), while a @dfn{passive} orientation convention assumes that which describes a basis transformation from the crystal basis to the sample basis (“crystal-to-sample”).

The following @code{@var{orientation_descriptor}} types are available (associated per-line formats are also described):

@c {@bf NOTE: it feels a bit overkill to provide the definition of the orientation descriptors, but fine.}

@itemize

@item For @samp{rodrigues}, each orientation is described by @math{r_1, r_2, r_3}, where the Rodrigues vector is
@iftex
@math{{@bf r} = {@bf t} \tan{(\omega / 2)} }.
@end iftex
@ifinfo
@math{{r} = {t} \tan{(\omega / 2)} }.
@end ifinfo
The per-line format is:

@inputfilehead
@example
@var{entity_id} @var{r_1} @var{r_2} @var{r_3}
@end example
@inputfilefoot

@c where @code{@var{r_*}} are the components of the Rodrigues orientation vector, which is related to the axis-angle parameterization via: @math{\bf{r} = \bf{t} \tan{ \omega \over 2} }.

@item For @samp{euler-bunge}, each orientation is described by @math{\phi_1, \theta, \phi_2}, where @math{\phi_1} is the rotation about the @math{z} axis, @math{\theta} is the rotation about the @math{z^{\prime}} axis, and @math{\phi_2} is the rotation about the @math{z^{\prime \prime}} axis, all in degrees). The per-line format is:

@inputfilehead
@example
@var{entity_id} @var{phi_1} @var{Phi} @var{phi_2}
@end example
@inputfilefoot

@c where @code{@var{Psi}} is the rotation about the @var{z} axis, @code{@var{Theta}} is the rotation about the @var{y'} axis, and @code{@var{phi}} is the rotation about the @var{z''} axis, all in degrees.

@item For @samp{euler-kocks}, each orientation is described by @math{\Psi, \Theta, \phi}, where @math{\Psi} is the rotation about the @math{z} axis, @math{\Theta} is the rotation about the @math{y^{\prime}} axis, and @math{\phi} is the rotation about the @math{z^{\prime \prime}} axis, all in degrees). The per-line format is:

@inputfilehead
@example
@var{entity_id} @var{Psi} @var{Theta} @var{phi}
@end example
@inputfilefoot

@c where @code{@var{phi_1}} is the rotation about the @var{z} axis, @code{@var{Phi}} is the rotation about the @var{x'} axis, and @code{@var{phi_2}} is the rotation about the @var{z''} axis, all in degrees. Note that the descriptor @samp{euler} refers specifically to Euler-Bunge orientations and should not be confused with any other similar Euler angle orientation convention.

@item For @samp{axis-angle}, each orientation is described by @math{t_1, t_2, t_3, \omega}, where @math{\bf{t}} is the normalized axis of rotation and @math{\omega} is the angle of rotation about said axis, in degrees. The per-line format is:

@inputfilehead
@example
@var{entity_id} @var{t_1} @var{t_2} @var{t_3} @var{omega}
@end example
@inputfilefoot

@c where @code{@var{t_*}} are the components of the normalized axis of rotation, and @code{@var{omega}} is the angle of rotation about said axis in degrees.

@item For @samp{quaternion}, each orientation is described by @math{q_0, q_1, q_2, q_3}, where @math{q_0 = \cos{(\omega / 2)}} and @math{q_i = t_i \sin{(\omega / 2)}} for @math{i = 1, 2, 3}. The per-line format is:

@inputfilehead
@example
@var{entity_id} @var{q_0} @var{q_1} @var{q_2} @var{q_3}
@end example
@inputfilefoot

@c where @code{@var{q_*}} are the components of the quaternion vector, which is related to the axis-angle parameterization via: @math{q_0 = \cos{ \omega \over 2 }} and @math{q_i = t_i \sin{\omega \over 2}} for @math{i = 1, 2, 3}.

@end itemize

@node External Crystallographic Phase Assignment (Optional)
@subsection External Crystallographic Phase Assignment (Optional, @file{simulation.phase})

The embedded grain/phase assignments within the @file{simulation.msh} may be overridden via an external @file{simulation.phase} file. This file contains formatting identical to the associated fields in the mesh file and is defined as:

@inputfilehead
@example
$Groups
@var{group_entity}
@var{number_of_group_entities}
@var{entity_id} @var{group}
...
$EndGroups
@end example
@inputfilefoot

where @code{@var{group_entity}} defines the phase assignment method and must always be defined as @samp{elset}, @code{@var{number_of_group_entities}} is the number of grain/phase pairs defined in the field, @code{@var{entity_id}} is a unique 1-indexed identification number, and @code{@var{group}} is an 1-indexed value that defines the phase for a given grain.

@node The Fiber Averaging File (Optional)
@section The Fiber Averaging File (Optional, @file{simulation.fib})

This file contains the definitions of crystallographic fibers. For each crystallographic fiber, the values of certain simulation variables are averaged (and the standard deviation calculated) for the elements which are oriented such that they belong to each fiber. Additionally, statistics on the elements that belong to each fiber are printed, such as the number of elements, the volume of the collective elements, and the list of elements that belong to a fiber. A full description of the fiber averaging output is discussed later (@pxref{Fiber Averaging Output} for a description of this output).

The structure of the @file{simulation.fib} is as follows:

@inputfilehead
@example
@var{h k l} @var{u v w} @var{phase} @var{ang_tol}
...
@end example
@inputfilefoot

Each line defines a single crystallographic fiber, where @code{@var{h k l}} are integer values for the crystallographic direction, @code{@var{u v w}} are real values for the sample direction, @code{@var{phase}} is an integer that specifies the crystallographic phase (beginning with 1), and @code{@var{ang_tol}} is a real value that defines the angular tolerance for which to accept a crystal as belonging to a fiber. All 8 values describing a fiber are expected to be separated by a space. The values provided for @code{@var{phase}} must correspond to the phase identification numbers defined in the @file{simulation.config} file. 
